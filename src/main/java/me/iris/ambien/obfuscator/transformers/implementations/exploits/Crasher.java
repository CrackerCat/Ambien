package me.iris.ambien.obfuscator.transformers.implementations.exploits;

import me.iris.ambien.obfuscator.builders.ClassBuilder;
import me.iris.ambien.obfuscator.settings.data.implementations.BooleanSetting;
import me.iris.ambien.obfuscator.transformers.data.Category;
import me.iris.ambien.obfuscator.transformers.data.Transformer;
import me.iris.ambien.obfuscator.transformers.data.annotation.TransformerInfo;
import me.iris.ambien.obfuscator.utilities.StringUtil;
import me.iris.ambien.obfuscator.wrappers.ClassWrapper;
import me.iris.ambien.obfuscator.wrappers.JarWrapper;
import org.objectweb.asm.tree.AnnotationNode;
import org.objectweb.asm.tree.ClassNode;

import java.util.ArrayList;

@TransformerInfo(
        name = "crasher",
        category = Category.EXPLOITS
)
public class Crasher extends Transformer {
    /**
     * Crashes swing based decompilers because of them trying to render the html
     */
    public final BooleanSetting incompleteHypertext = new BooleanSetting("incomplete-hypertext", true);
    /**
     * Adds long end-line character annotations to methods & fields
     * This causes decompilers to be very slow or not decompile at all
     */
    public final BooleanSetting badAnnotations = new BooleanSetting("bad-annotations", true);
    /**
     * Adds random text to null method & class signatures, most decompilers will crash or just ignore it
     */
    public static final BooleanSetting junkSignatures = new BooleanSetting("junk-signatures", true);
    /**
     * Adds a class that inherits itself, causing some tools to get stuck in an infinite loop of decompiling the class
     */
    public final BooleanSetting selfInheritance = new BooleanSetting("self-inheritance", true);

    @SuppressWarnings({"rawtypes", "unchecked"})
    @Override
    public void transform(JarWrapper wrapper) {
        // Add incomplete hypertext
        if (incompleteHypertext.isEnabled())
            wrapper.getResources().put("<html><img src=\"https:%s", new byte[]{});

        // Add bad annotations
        if (badAnnotations.isEnabled()) {
            wrapper.getClasses().forEach(classWrapper -> {
                // Add invisible annotations to methods
                classWrapper.getMethods().forEach(methodNode -> {
                    if (methodNode.invisibleAnnotations == null)
                        methodNode.invisibleAnnotations = new ArrayList();

                    methodNode.invisibleAnnotations.add(new AnnotationNode(StringUtil.repeat('\n', 100)));
                });

                // Add invisible annotations to fields
                classWrapper.getFields().forEach(fieldNode -> {
                    if (fieldNode.invisibleAnnotations == null)
                        fieldNode.invisibleAnnotations = new ArrayList();
                    fieldNode.invisibleAnnotations.add(new AnnotationNode(StringUtil.repeat('\n', 100)));
                });
            });
        }

        // Add junk to method signatures
        if (junkSignatures.isEnabled()) {
            wrapper.getClasses().forEach(classWrapper -> {
                // Add junk signature to class
                classWrapper.getNode().signature = StringUtil.randomString(15);

                // Add junk signature to methods
                classWrapper.getMethods().forEach(methodNode -> {
                    if (methodNode.signature != null) return;
                    methodNode.signature = StringUtil.randomString(15);
                });
            });
        }

        // Add a class that inherits itself
        if (selfInheritance.isEnabled()) {
            final String name = StringUtil.randomString(15);
            final ClassBuilder builder = new ClassBuilder().setName(name).setSuperName(name).setAccess(ACC_PUBLIC);
            final ClassNode node = builder.buildNode();
            wrapper.getClasses().add(new ClassWrapper(name + ".class", node));
        }
    }
}
